{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to my personal documentation!","text":"<p>This repo contains some documentation on various topics so I can refresh my knowledge when I need to. It mostly contains things I have a hard time remembering, or that may be diffucult to find on the internet, but I may add anything to it that I like or find useful at any point.</p> <p>I decided to put it online at the request of some colleagues and for anyone who may stumble upon it.</p>"},{"location":"about/","title":"About","text":"<p>This is the about page</p>"},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#tag:cmake","title":"Cmake","text":"<ul> <li>            CMake build tools          </li> <li>            Export import          </li> </ul>"},{"location":"tags/#tag:directx12","title":"DirectX12","text":"<ul> <li>            Barriers          </li> <li>            Color blending          </li> <li>            Descriptors          </li> <li>            HLSL          </li> <li>            Root Signature          </li> <li>            Shaders          </li> <li>            Viewport          </li> </ul>"},{"location":"tags/#tag:powersaving---pc","title":"Powersaving - PC","text":"<ul> <li>            BIOS powersaving tricks          </li> </ul>"},{"location":"tags/#tag:wol","title":"WOL","text":"<ul> <li>            Networking          </li> </ul>"},{"location":"workspace/CMake/cmake/","title":"CMake build tools","text":"","tags":["Cmake"]},{"location":"workspace/CMake/cmake/#visual-studio-debugging-properties","title":"Visual Studio Debugging Properties","text":"<p>Variable to populate the <code>Local Windows Debugger</code> properties in visual studio. Properties -&gt; Debugging. Can be used to generate which executables to launch and attach to etc.</p> <p><code>VS_DEBUGGER_ENVIRONMENT</code></p>","tags":["Cmake"]},{"location":"workspace/CMake/cmake/#launch-app-with-administrator-privileges","title":"Launch app with administrator privileges:","text":"<p>This can be used for flutter apps to make them launch with administrator privileges. This probably works with other cmake programs as well.</p> <p>Source</p> <pre><code>SET_TARGET_PROPERTIES(${BINARY_NAME} PROPERTIES LINK_FLAGS    \"/MANIFESTUAC:\\\"level='requireAdministrator' uiAccess='false'\\\" /SUBSYSTEM:WINDOWS\")\n</code></pre>","tags":["Cmake"]},{"location":"workspace/CMake/cmake/#package-system-dependecies","title":"Package system dependecies","text":"<p>Packages OS/System dll's with the output binaries of the target.</p> <pre><code>install(RUNTIME_DEPENDENCY_SET)\n</code></pre>","tags":["Cmake"]},{"location":"workspace/CMake/cmake/#post-build-step-copy-output-files-to-other-directory","title":"Post build step, copy output files to other directory","text":"<p>List of generator expressions: Source</p> <p>$ <pre><code>find_package(foo CONFIG REQUIRED) # package generated by install(EXPORT)\n\nadd_executable(exe main.c)\ntarget_link_libraries(exe PRIVATE foo::foo foo::bar)\nadd_custom_command(TARGET exe POST_BUILD\n  COMMAND ${CMAKE_COMMAND} -E copy -t $&lt;TARGET_FILE_DIR:exe&gt; $&lt;TARGET_RUNTIME_DLLS:exe&gt;\n  COMMAND_EXPAND_LISTS\n)\n</code></pre>","tags":["Cmake"]},{"location":"workspace/CMake/export_import/","title":"Export import","text":"<p>Source</p>","tags":["Cmake"]},{"location":"workspace/CMake/export_import/#exporting-source","title":"Exporting Source","text":"","tags":["Cmake"]},{"location":"workspace/CMake/export_import/#package-configuration-file-configcmake-source","title":"Package Configuration file (Config.cmake) Source","text":"","tags":["Cmake"]},{"location":"workspace/CMake/export_import/#set_and_check","title":"set_and_check()","text":"<p>Don't use <code>set()</code> in this file for file locations and directories, only <code>set_and_check()</code>. It runs on the users PC and needs to check if the file/directory is available.</p>","tags":["Cmake"]},{"location":"workspace/CMake/export_import/#linking-with-dependencies","title":"Linking with dependencies","text":"<p>Dependencies need to be linked in side this file to make sure they're available and so CMake knows it comes from the library. So if the project links to a library with <code>PUBLIC</code> it should have the <code>find_dependency</code> command for it in the package configuration file. </p> <pre><code>include(CMakeFindDependencyMacro)\nfind_dependency(Stats 2.6.4)\n</code></pre>","tags":["Cmake"]},{"location":"workspace/CMake/export_import/#importing-pre-built-libraries-source","title":"Importing pre-built libraries Source","text":"<p>in the rule to link myexe. On Windows a .dll and its .lib import library may be imported together:</p> <pre><code>add_library(bar SHARED IMPORTED)\nset_property(TARGET bar PROPERTY IMPORTED_LOCATION c:/path/to/bar.dll)\nset_property(TARGET bar PROPERTY IMPORTED_IMPLIB c:/path/to/bar.lib)\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe bar)\n</code></pre> <p>in the rule to link myexe. A library with multiple configurations may be imported with a single target:</p> <pre><code>add_library(foo STATIC IMPORTED)\nset_property(TARGET foo PROPERTY IMPORTED_LOCATION_RELEASE c:/path/to/foo.lib)\nset_property(TARGET foo PROPERTY IMPORTED_LOCATION_DEBUG   c:/path/to/foo_d.lib)\nadd_executable(myexe src1.c src2.c)\ntarget_link_libraries(myexe foo)\n</code></pre>","tags":["Cmake"]},{"location":"workspace/DirectX/barriers/","title":"Barriers","text":"<p>Microsoft resource </p>","tags":["DirectX12"]},{"location":"workspace/DirectX/barriers/#split-barriers","title":"Split Barriers","text":"<p>A resource transition barrier with the D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY flag begins a split barrier and the transition barrier is said to be pending. While the barrier is pending the (sub)resource cannot be read or written by the GPU. The only legal transition barrier that can be applied to a (sub)resource with a pending barrier is one with the same\u00a0before\u00a0and\u00a0after\u00a0states and the D3D12_RESOURCE_BARRIER_FLAG_END_ONLY flag, which barrier completes the pending transition.</p> <p>Split barriers provide hints to the GPU that a resource in state\u00a0A\u00a0will next be used in state\u00a0B\u00a0sometime later. This gives the GPU the option to optimize the transition workload, possibly reducing or eliminating execution stalls. Issuing the end-only barrier guarantees that all GPU transition work is finished before moving onto the next command.</p> <p>Using split barriers can help to improve performance, especially in multi-engine scenarios or where resources are read/write transitioned sparsely throughout one or more command lists.</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/barriers/#example-of-split-barriers","title":"Example of split barriers","text":"<p>The following example shows how to use a split barrier to reduce pipeline stalls. The code that follows does not use split barriers:</p> <pre><code>D3D12_RESOURCE_BARRIER BarrierDesc = {};\nBarrierDesc.Type = D3D12_RESOURCE_BARRIER_TRANSITION; \nBarrierDesc.Flags = D3D12_RESOURCE_BARRIER_NONE; \nBarrierDesc.Transition.pResource = pResource; \nBarrierDesc.Transition.Subresource = 0; \nBarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_COMMON; BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET; \n\npCommandList-&gt;ResourceBarrier( 1, \\&amp;BarrierDesc ); \n\nWrite(pResource); // ... render to pResource \nOtherStuff(); // .. other gpu work \n\n// Transition pResource to PIXEL\\_SHADER\\_RESOURCE \nBarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET; BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE; \n\npCommandList-&gt;ResourceBarrier( 1, &amp;BarrierDesc ); Read(pResource); // ... read from pResource\n</code></pre> <p>The following code uses split barriers:</p> <pre><code>D3D12_RESOURCE_BARRIER BarrierDesc = {}; \nBarrierDesc.Type = D3D12_RESOURCE_BARRIER_TRANSITION; \narrierDesc.Flags = D3D12_RESOURCE_BARRIER_NONE; \nBarrierDesc.Transition.pResource = pResource; \nBarrierDesc.Transition.Subresource = 0; \nBarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_COMMON; BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET; \n\npCommandList-&gt;ResourceBarrier( 1, \\&amp;BarrierDesc ); Write(pResource); // ... render to pResource \n\n// Done writing to pResource. Start barrier to PIXEL_SHADER_RESOURCE and \n// then do other work \nBarrierDesc.Flags = D3D12_RESOURCE_BARRIER_BEGIN_ONLY; \nBarrierDesc.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET; BarrierDesc.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;\npCommandList-&gt;ResourceBarrier( 1, &amp;BarrierDesc ); \nOtherStuff(); // .. other gpu work \n\n// Need to read from pResource so end barrier \nBarrierDesc.Flags = D3D12_RESOURCE_BARRIER_END_ONLY; \n\npCommandList-&gt;ResourceBarrier( 1, &amp;BarrierDesc );\nRead(pResource); // ... read from pResource\n</code></pre>","tags":["DirectX12"]},{"location":"workspace/DirectX/color%20blending/","title":"Color blending","text":"<p>Blend States Output Merger (OM)</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/descriptors/","title":"Descriptors","text":"<p>Documentation about usage of descriptors.  Docs</p> <p>Three main parts</p> <ol> <li>Descriptor heaps</li> <li>Desciptors</li> <li>Descriptor tables</li> </ol>","tags":["DirectX12"]},{"location":"workspace/DirectX/descriptors/#descriptor-tables","title":"Descriptor Tables:","text":"","tags":["DirectX12"]},{"location":"workspace/DirectX/descriptors/#advanced-usage","title":"Advanced Usage","text":"<p>Advanced usage docs - Dynamic indexing - Descriptor table versioning</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/hlsl/","title":"HLSL","text":"","tags":["DirectX12"]},{"location":"workspace/DirectX/hlsl/#registers","title":"Registers","text":"<p>Registers docs</p> <p>Appearently registers are stored in a register space. Note the word <code>space</code> in the register field: <code>int variable : register(t1, space0)</code></p> <p>From the docs:</p> <pre><code>Texture2D&lt;float4&gt; tex1 : register(t3,  space0)\nTexture2D&lt;float4&gt; tex2[4] : register(t10)\nTexture2D&lt;float4&gt; tex3[7][5][3] : register(t20, space1)\n</code></pre> <p>SM5.1 declaration limits are more flexible, and constrained only by the runtime/hardware limits.  <code>The space keyword specifies to which logical register space the declared variable is bound.</code> If the space keyword is omitted, then the default space index of 0 is implicitly assigned to the range (so the tex2 range above resides in space0).  <code>register(t3, space0)</code> will never conflict with register(t3, space1), nor with any array in another space that might include t3.</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/root_signature/","title":"Root Signature","text":"<p>Microsoft resource</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/root_signature/#flags","title":"FLAGS","text":"<p>Can have multiple flags you have to watch out for. <code>DATA_STATIC</code> for example These flags are set on the descriptor ranges.</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/root_signature/#data_static","title":"DATA_STATIC","text":"<p>If this flag is set, the data pointed to by descriptors has been initialized by the time a root descriptor or descriptor table referencing the memory has been set on a command list / bundle during recording, and the data cannot be changed until the command list / bundle has finished executing for the last time.</p> <p>For bundles, the static duration starts at root descriptor or descriptor table setting during the recording of the bundle, as opposed to recording of a calling command list. In addition, a descriptor table pointing to static data must be set in the bundle and not inherited. It is valid for a command list to use a descriptor table pointing to static data that has been set in a bundle and returned back to the command list.</p> <p>The flag is available in both descriptor range flags and root descriptor flags.</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/shaders/","title":"Shaders","text":"<p>The Book of Shaders</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/shaders/#dx-shaders","title":"DX Shaders","text":"<p>Resource Binding</p> <p>HLSL in Vulkan</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/viewport/","title":"Viewport","text":"<p>DX Viewports Some more on viewports and rendering</p>","tags":["DirectX12"]},{"location":"workspace/DirectX/viewport/#scissor-test","title":"Scissor Test","text":"<p>Scissor Test</p>","tags":["DirectX12"]},{"location":"workspace/Git/git/","title":"Git References","text":"<p>Using ssh-agent as main ssh provider for Git <code>git config --global core.sshCommand C:/Windows/System32/OpenSSH/ssh.exe</code></p>"},{"location":"workspace/Linux/networking_topics/","title":"Networking","text":"","tags":["WOL"]},{"location":"workspace/Linux/networking_topics/#wake-on-lan","title":"Wake On lan","text":"","tags":["WOL"]},{"location":"workspace/Linux/networking_topics/#enable-wol-on-the-network-adapter-source","title":"Enable WoL on the network adapter Source","text":"<p>It is crucial to enable Wol for the ehternet interface, otherwise the port will just be turned off and Wol will only work a single time when powering on the switch/router.</p> <p>Don't forget to make this setting persistent as well or it will only work once.</p> <ol> <li> <p>Check if Wol is enabled on the adapter with <code>ethtool</code> <code>ethtool eth0 | grep Wake-on</code></p> </li> <li> <p>Enable Wol     <code>ethtool -s eth0 wol g</code></p> </li> <li> <p>Make the Wol setting persistent     Can be done with unraid <code>User Scripts</code> plugin. Add the ethtool command to the script and it should work.</p> <p>There are many alternatives to enable this automatically on Linux. Here is one using <code>systemd</code> For other options see the source page.</p> </li> </ol>","tags":["WOL"]},{"location":"workspace/Linux/networking_topics/#wol-persistency-with-systemdlink","title":"WOL persistency with systemd.link","text":"<p>Link-level configuration is possible through systemd.link files. The actual setup is performed by the net_setup_link udev builtin. Add the WakeOnLan option to the network link file: ``` file: /etc/systemd/network/50-wired.link</p> <p>[Match] MACAddress=aa:bb:cc:dd:ee:ff</p> <p>[Link] NamePolicy=kernel database onboard slot path MACAddressPolicy=persistent WakeOnLan=magic ``` Note: - Only the first matching file is applied. The content of the default link file /usr/lib/systemd/network/99-default.link shipped with systemd has to be included, otherwise the interface might be misconfigured. - To be considered, the file name should alphabetically come before the default 99-default.link. For example 50-wired.link works. - This configuration applies only to the link-level, and is independent of network-level daemons such as NetworkManager or systemd-networkd. - In the Match section, OriginalName= can also be used to identify the interface.</p>","tags":["WOL"]},{"location":"workspace/OpenXR/openxr/","title":"OpenXR","text":""},{"location":"workspace/OpenXR/openxr/#loader","title":"Loader","text":"<p>The loader loads a manifest file from the registry key <code>Computer\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Khronos\\OpenXR\\1</code> with value <code>ActiveRuntime</code></p>"},{"location":"workspace/OpenXR/openxr/#open-source-testing-applications","title":"Open source testing applications","text":"<p>The helloxr exmaple from Khronos and UEVR worked the best for so far implementing a runtime.</p> <ul> <li>helloxr</li> <li>UEVR</li> </ul>"},{"location":"workspace/OpenXR/openxr/#other-open-source-projects-that-use-openxr","title":"Other open source projects that use OpenXR","text":"<ul> <li>Open Brush</li> <li>V-Sekai</li> <li>Mine Test</li> </ul>"},{"location":"workspace/Server/BIOS/","title":"BIOS powersaving tricks","text":"","tags":["Powersaving - PC"]},{"location":"workspace/Server/BIOS/#cpu-and-package-c-states","title":"CPU and Package C-states","text":"<p>Typically go from C1 - C10 where C10 is a low idle power mode.</p> <p>Higher package powerstates can be hard to reach since it depends on whether the motherboard and other hardware components support it in their drivers.</p>","tags":["Powersaving - PC"]},{"location":"workspace/Server/BIOS/#aspm","title":"ASPM","text":"<p>Source</p> <p>ASPM is the power management capability of hardware to effectively reduce usage of power by placing the PCI Express(PCIe) based serial link devices to low-power state when not in use. ASPM is controlled by BIOS or the power management component of the operating system in two configurations.</p>","tags":["Powersaving - PC"]},{"location":"workspace/Server/BIOS/#pcie-aspm-support","title":"PCIE ASPM support","text":"<p>L0 \u2013 All PCI Express transactions and other operations are enabled.</p> <p>L0s \u2013 A low resume latency, energy saving \u201cstandby\u201d state.</p> <p>L1 \u2013 Higher latency, lower power \u201cstandby\u201d state (optional).</p> <p>L0sL1 - Activate both L0s and L1 support.</p>","tags":["Powersaving - PC"]},{"location":"workspace/Vulkan/rendering_techniques/","title":"Rendering Techniques","text":"<p>Some rendering techniques I stumbled upon</p>"},{"location":"workspace/Vulkan/rendering_techniques/#clustered-forward-shading","title":"Clustered Forward shading","text":"<ul> <li>Clustered Forward shading</li> </ul> <p>Cool comment from the blog:</p> <pre><code>I toyed around with the code, added an extra ubo+descriptor for a point light source and rewrote the shaders for Blinn-Phong reflection. As an extra feature I implemented timestamp queries in the command buffer recording so I could measure GPU rendering time. Thankfully, the obj. model contains vertex normals as well.\nThank you so much for these tutorials - they are still (2021) very appreciated! xD\n</code></pre>"},{"location":"workspace/Vulkan/synchronization/","title":"Synchronization","text":"<p>Source - Yet another blog explaining Vulkan synchronization</p>"},{"location":"workspace/Vulkan/synchronization/#synchronization","title":"Synchronization","text":"<p>All commands in a queue are executed in an optimized order. But that happen on the Queue level, not in command buffers. Everything submitted to a queu is just a linear stream of commands. And synchronization applies globally to a queue. THere is also command overlap, so reordering may happen between command buf</p>"},{"location":"workspace/Vulkan/synchronization/#barriers","title":"Barriers","text":"<p>There are different types of Barriers</p> <p>First <code>Execution barriers</code>. Note: These fall under <code>Memory barriers</code></p>"},{"location":"workspace/Vulkan/synchronization/#execution-barriers","title":"Execution Barriers","text":"<p>vkCmdPipelineBarrier</p> <pre><code>void vkCmdPipelineBarrier(\n    VkCommandBuffer                             commandBuffer,\n    VkPipelineStageFlags                        srcStageMask,\n    VkPipelineStageFlags                        dstStageMask,\n    VkDependencyFlags                           dependencyFlags,\n    uint32_t                                    memoryBarrierCount,\n    const VkMemoryBarrier*                      pMemoryBarriers,\n    uint32_t                                    bufferMemoryBarrierCount,\n    const VkBufferMemoryBarrier*                pBufferMemoryBarriers,\n    uint32_t                                    imageMemoryBarrierCount,\n    const VkImageMemoryBarrier*                 pImageMemoryBarriers);\n</code></pre> <p>Ignore memory barriers for now: <code>srcStageMask</code> and <code>dstStageMask</code> are left and are the heart of synchronization. This splits the command stream in two; Everything <code>before</code> the barrier and everything <code>after</code> the barrier.</p>"},{"location":"workspace/Windows/Debugging/","title":"Debugging","text":""},{"location":"workspace/Windows/Debugging/#process-monitor","title":"Process Monitor","text":"<p>Source Microsoft</p> <p>Traces every event of windows for example to check everything a process accesses or loads.</p> <p>Comment: Source</p> <pre><code>Trace all file access while your dll is trying to load. With this utility, you will see everything that that dll is trying to pull in and usually the problem can be determined from there.\n</code></pre>"},{"location":"workspace/Windows/Delayed%20Library%20Loading/","title":"Delayed Library Loading","text":""},{"location":"workspace/Windows/Delayed%20Library%20Loading/#in-cmake","title":"In CMake","text":"<p>Add delay load linker options through CMake. linking with <code>delayimp</code> add standard functions for handling delay loaded dlls from Microsoft.</p> <pre><code># Delay loading of Simulated Reality\n target_link_libraries(${PROJECT_NAME} PRIVATE delayimp)\n target_link_options(${PROJECT_NAME} PRIVATE \"/DELAYLOAD:$&lt;TARGET_FILE_BASE_NAME:3DGameBridge&gt;.dll\")\n target_link_options(${PROJECT_NAME} PRIVATE \"/DELAYLOAD:$&lt;TARGET_FILE_BASE_NAME:srDirectX::srDirectX&gt;.dll\")\n</code></pre> <p>Source Delayed Loading CMake</p>"},{"location":"workspace/Windows/Delayed%20Library%20Loading/#in-c","title":"In C++","text":"<p>Sources: - Source</p> <ul> <li>Extra in depth source</li> </ul> <p>Then a hook function can be added to handle delay loading manually. You can implement custom behaviour for each event.</p> <pre><code>FARPROC WINAPI delayHook(unsigned dliNotify, PDelayLoadInfo pdli)\n{\n    switch (dliNotify) {\n        case dliStartProcessing :\n\n            // If you want to return control to the helper, return 0.\n            // Otherwise, return a pointer to a FARPROC helper function\n            // that will be used instead, thereby bypassing the rest\n            // of the helper.\n\n            break;\n\n        case dliNotePreLoadLibrary :\n\n            // If you want to return control to the helper, return 0.\n            // Otherwise, return your own HMODULE to be used by the\n            // helper instead of having it call LoadLibrary itself.\n\n            break;\n\n        case dliNotePreGetProcAddress :\n\n            // If you want to return control to the helper, return 0.\n            // If you choose you may supply your own FARPROC function\n            // address and bypass the helper's call to GetProcAddress.\n\n            break;\n\n        case dliFailLoadLib :\n\n            // LoadLibrary failed.\n            // If you don't want to handle this failure yourself, return 0.\n            // In this case the helper will raise an exception\n            // (ERROR_MOD_NOT_FOUND) and exit.\n            // If you want to handle the failure by loading an alternate\n            // DLL (for example), then return the HMODULE for\n            // the alternate DLL. The helper will continue execution with\n            // this alternate DLL and attempt to find the\n            // requested entrypoint via GetProcAddress.\n\n            break;\n\n        case dliFailGetProc :\n\n            // GetProcAddress failed.\n            // If you don't want to handle this failure yourself, return 0.\n            // In this case the helper will raise an exception\n            // (ERROR_PROC_NOT_FOUND) and exit.\n            // If you choose, you may handle the failure by returning\n            // an alternate FARPROC function address.\n\n            break;\n\n        case dliNoteEndProcessing :\n\n            // This notification is called after all processing is done.\n            // There is no opportunity for modifying the helper's behavior\n            // at this point except by longjmp()/throw()/RaiseException.\n            // No return value is processed.\n\n            break;\n\n        default :\n\n            return NULL;\n    }\n\n    return NULL;\n}\n\n/*\nand then at global scope somewhere:\nExternC const PfnDliHook __pfnDliNotifyHook2 = delayHook;\nExternC const PfnDliHook __pfnDliFailureHook2 = delayHook;\n*/\n</code></pre>"},{"location":"workspace/Windows/Screen%20resolution/","title":"Screen Resolution","text":""},{"location":"workspace/Windows/Screen%20resolution/#dpi-awareness","title":"DPI awareness","text":"<p>Source Set DPI Awareness</p> <p>Either use</p> <pre><code>// Preferred, also has more features\nBOOL SetProcessDpiAwarenessContext(\n  [in] DPI_AWARENESS_CONTEXT value\n);\n\nor \n\n// Shcore.lib may have to be linked as well\nHRESULT SetProcessDpiAwareness(\n  [in] PROCESS_DPI_AWARENESS value\n);\n</code></pre>"},{"location":"workspace/Windows/Screen%20resolution/#get-the-native-screen-resolution-stack-overflow","title":"Get the native screen resolution (Stack Overflow)","text":"<p>Source Stack Overflow</p> <p>The following answer was tested with <code>SetProcessDPIAware()</code> and without. In all cases, it gave the correct values.</p> <p>I did not found it anywhere on the internet so I am glad to share my knowledge with the world.</p>"},{"location":"workspace/Windows/Screen%20resolution/#to-get-real-monitor-resolution","title":"To get real monitor resolution","text":"<pre><code>void GetMonitorRealResolution(HMONITOR monitor, int* pixelsWidth, int* pixelsHeight)\n{\n    MONITORINFOEX info = { sizeof(MONITORINFOEX) };\n    winrt::check_bool(GetMonitorInfo(monitor, &amp;info));\n    DEVMODE devmode = {};\n    devmode.dmSize = sizeof(DEVMODE);\n    winrt::check_bool(EnumDisplaySettings(info.szDevice, ENUM_CURRENT_SETTINGS, &amp;devmode));\n    *pixelsWidth = devmode.dmPelsWidth;\n    *pixelsHeight = devmode.dmPelsHeight;\n}\n</code></pre> <p>It will return that native resolution in any case, even if the OS tries to lie to you due to the DPI awareness of the process.</p>"},{"location":"workspace/Windows/Screen%20resolution/#to-get-the-scaling-ratio-between-the-virtual-resolution-and-real-resolution","title":"To get the scaling ratio between the virtual resolution and real resolution","text":"<pre><code>float GetMonitorScalingRatio(HMONITOR monitor)\n{\n    MONITORINFOEX info = { sizeof(MONITORINFOEX) };\n    winrt::check_bool(GetMonitorInfo(monitor, &amp;info));\n    DEVMODE devmode = {};\n    devmode.dmSize = sizeof(DEVMODE);\n    winrt::check_bool(EnumDisplaySettings(info.szDevice, ENUM_CURRENT_SETTINGS, &amp;devmode));\n    return (info.rcMonitor.right - info.rcMonitor.left) / static_cast&lt;float&gt;(devmode.dmPelsWidth);\n}\n</code></pre> <p>This will give you a ratio of the real resolution relative to the virtual resolution of the given monitor.</p> <p>If the main DPI of the main monitor is 225% and on the second monitor it is 100%, and you run this function for the second monitor, you will get 2.25. because <code>2.25 * real resolution</code> = <code>the virtual resolution</code> of the monitor.</p> <p>If the second monitor has 125% scaling (while the main monitor is still 225% scaling), then this function will return you <code>1.79999995</code> because 125% relative to 225% is this value (225/125 = 1.8), and again - 1.8 * real resolution=the virtual resolution of 125%`</p>"},{"location":"workspace/Windows/Screen%20resolution/#to-get-the-real-dpi-value-not-relative-to-anything","title":"To get the real DPI value (not relative to anything)","text":"<p>Given that monitor, A has 225% DPI, and monitor B has 125% DPI, as I said above, you will not get 1.25 for the second monitor (if you run the function on the second monitor. You will get 1.8 as I said).</p> <p>To overcome this, use this function:</p> <pre><code>float GetRealDpiForMonitor(HMONITOR monitor)\n{\n    return GetDpiForSystem() / 96.0 / GetMonitorScalingRatio(monitor);\n}\n</code></pre> <p>This function depends on the previous function that I wrote above (the function <code>GetMonitorScalingRatio</code> that you need to copy)</p> <p>This will give you the correct value.</p>"}]}